#daily

## 今日取り組んだタスク

- [ ] 中間試験：SQL　完了
- [ ] スッキリわかるSQL入門
- [ ] チェリー本

---
---
## 一言

久しぶりにpaizaの問題を解いてて、その問題の解説に「Enumerator オブジェクト」とか
見たことない用語が出てきたので、調べてみたんですが.......「外部イテレータ？BasicObject？なにそれ？」
っと沼りそうだったんで、一旦傍に置いた1日でしたw

---
---
## 学習内容

### Ruby

#### クラスの継承に関する用語

##### スーパークラスとサブクラス

説明：
DVDクラスとProductクラスがあったとし、DVDクラスはProdactクラスを継承しているとする
このときProductクラスは、DVDクラスの親クラスであり、スーパークラスと呼び
逆に、DVDクラスは、Productクラスの子クラスであり、サブクラスと呼ぶ
また
継承として使いたいときに、機能ではなく「性質や概念」に着目すること！
これは、**安易な機能の再利用のために継承を使わないように**という意図で書かれていると思う？

継承したい！っと思った時、具体的に判断するポイントは
「サブクラスはスーパークラスの一種である」（サブクラス is a スーパークラス）」と声に出して
違和感がないか確かめることである

例：
管理販売を行うシステムで、商品クラスがスーパークラス、DVDクラスがサブクラスなら
「DVDは、商品の一種である（DVD is a product）」
これだと、商品と比べてDVDと読んだ方がより性質や概念が具体的になる（読み込み用ディスク、円盤）
逆に商品は、「売るために何か」っと言うことぐらいしか、イメージができない
これは
具体と抽象、特化と汎化の関係に当たる！これをイメージして、継承が適切かどうか判断する！


___

###  Rails
```ruby
def create @task = Task.new(task_params) 
	if @task.save
		redirect_to @task, notice: 'タスクが作成されました。'
	else
		render :new
	end
end
```

解説
@taskで保存する際には、データベースに **INSERT** を実行をしている
また、ここで失敗するときは、バリデーションに引っかかった場合である

##### 「redirect_to @task」で詳細ページにリダイレクトするのはなぜなのか？

1. `@task` が id:1 の Task オブジェクトなら、Rails は自動で URL `/tasks/1` を生成
2. `/tasks/1` は `tasks#show` にルーティングされるので、結果として **showアクションにリダイレクト** される

つまり
- `redirect_to @task` → Rails が自動で `task_path(@task)` を計算
- `task_path(@task)` → `/tasks/:id` → `tasks#show`
- だから `create` の後にタスク詳細ページに飛ぶ

補足
redirect_to task_path(@task)と書き換えることもできる

---
### SQL

**主キー**

説明：
この値を指定すれば、ある1行を完全に特定できる役割を持つカラムのこと！
社員番号や入出金IDなどが主キーとなる

役割：
以下の特徴
- 必ず何かしらのデータが格納されている
- 他の行と重複しない
- 一度決めた値は変化しない

を持つことで、WHERE句であらゆる行をいつでも自由に特定できるから
唯一無二の存在となる

補足
社員番号のようなカラムは、自然キーと呼ばれて
それに対して、入出金IDのような管理目的だけに人為的に作られたカラムを人工キーや代替キーと呼ぶ

必要性：
以下のテーブル：家計簿があったとする

| 日付         | 費目    | メモ        | 入金額 | 出金額  |
| ---------- | ----- | --------- | --- | ---- |
| 2024-03-03 | 食費    | チョコレートを購入 | 0   | 100  |
| 2024-03-03 | 食費    | チョコレートを購入 | 0   | 100  |
| 2024-03-06 | 教養娯楽費 | 月刊SQLを購入  | 0   | 1280 |

上の1行だけ削除する方法を考えた場合
```sql
DELETE
  FROM 家計簿
 WHERE 日付 = '2024-03-03'
   AND 出金額 - 100
```

どうしても、2つのレコードが削除されてしまう
なので、<font color="#ff0000">テーブルの中に重複した行が格納される状況は避けるべき</font>である

よって、主キーはこのような状況を回避するために必要である

補足
ただし、単独では重複する可能性がある列でも、複数の列を組み合わせれば
実質重複する可能性がなくなる場合がある
複数の列を一つ主キーとするものを複合主キーと呼ぶ


**DISTINCT**

説明：
SELECT文に指定してあげることで、重複した行を取り除くことができるキーワード

流れ：
1. SELECT文で指定したものを抽出する
2. DISTINCTで加工して、重複を取り除く

注意
DISTINCTは選択列リストより先に書く必要がある

---
### MySQL

**MySQLの対話モード**
- **前に入力したコマンドが未完（`;`で終わっていないなど）** の場合、次の行を「同じコマンドの続き」として扱う
- `->` が出ているときは **まだ前のコマンドが終わっていない** 状態
- だから、そのまま別のSELECTを書くと、文法エラー（syntax error）になってしまう

---
### paiza

#### 何度か値を受け取るなら
```ruby
Apple
Banana
```

```ruby
# 分けて受け取る
s = gets.chomp
t = gets.chomp

# 一度に受け取る
s = Array.new(2) {gets.chomp}
```


#### 【 配列の多重代入 】
```ruby
#Hello  Worldを半角文字で区切って出力する
a, b = "Hello World".split(" ")
puts a
puts b
```

補足
左辺の変数の数 > 区切った配列の要素の数において
過分してる変数には、nilが入る

```ruby
# 1~5を英語にした文字列の半角スペース区切りで分割する
'one two three four five'.split(' ').each { |val| puts val }

'one two three four five'.split(' ').each do |a|
	puts a
end


```

解説
- 解答の流れ、考え方は以下の通り
    - `'one two three four five'` を split メソッドを用いて半角スペースで区切り配列 `[one, two, three, four, five]` を生成する
    - each メソッドを用いて配列の各要素を取得して `puts val` で出力する



#### 「半角スペース区切りの 10 個の入力 」

```ruby
# 標準入力
F5G6 0KSYzlF ghYYhAw NHCSxgPMbE EYqKRElk 8UYzUH 6mxtW 0tt1n 2cEaAQs gAWn
```

```ruby
ary = gets.split(' ')
ary.each { |val| puts val }
```

補足
- each メソッドのポイントは以下の通り
    - `配列.each { |a| 処理 }` または `配列.each do |a| 処理 end` で配列の各要素を変数 a に代入しながら `処理` ができる
- また、変数 ary を用意せず、`gets.split.(' ').each { |val| puts val }` で解くこともできます。
	- 上記に加えて、`gets.split.each { |val| puts val }` でも解くことができる


#### 100 行の整数の入力（１〜１００）

##### パターン１
```ruby
a = Array.new(100)
100.times { |i| a[i] = gets.to_i }

a.each { |val| puts val }
```

解説
１：
`Array.new(n)` で**要素数が100の配列**を生成することができる
ただし、この時点では中身はすべて nil

２：
`100.times` を用いて、配列の各要素に入力値を代入（`a[]`の`[]`は、各要素の位置はインデックス）
例
i = 0 のとき → `a[0] = gets.to_i`
i = 1 のとき → `a[1] = gets.to_i`
i = 2 のとき → `a[2] = gets.to_i`
・
・
・
i = 99のとき → `a[99] = gets.to_i`
結果
`a = [1, 2, 3, ・・・・・・・, 100]`

３：
最後に each メソッドを用いて、配列の各要素を出力

##### パターン２
```sql
a = 1000.times.map { gets.to_i }
a.each { |val| puts val }
```


##### パターン３
```sql
ary = Array.new(100) {gets.chomp.to_i}
puts ary
```

---
---
## 学んだこと

Ruby
- スパークラス、サブクラスなどの継承の基本について
Rails
- redirect_to @taskの処理について
SQL
- 主キーの役割について
- **DISTINCT**について
MySQL
- **MySQLの対話モード**に関する注意点
paiza
- `配列.each {|val| puts val}`について

---
---
## 教材

- チェリー本
- スッキリわかるSQL入門
- paiza標準入力


---
---
##### ⏳ 学習時間: 3.5時間  
##### 🌱 コミット数: １コミット