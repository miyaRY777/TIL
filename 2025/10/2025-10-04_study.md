#daily

## 今日取り組んだタスク

- [ ] 基礎STEP 総復習 クイズ(復習)
- [ ] Web技術の基本chapter3の復習（想起学習）
- [ ] Railsガイドを読み込む



---


## 学習内容
### Ruby / Rails

## [[update]]

説明：
- AcitiveRecordが提供する既存のレコードを更新するメソッドのこと
- validatesで定義したチェックを通過するかどうかを自動で確認してから、更新が行われる
- 成功時はtrue、失敗時にはfalseで返す
	- ただし、失敗しても処理は最後まで続く


#### 使用例
```ruby
基本形：`モデル.update(ID=:all, 属性)`

@item = Item.find(1)
@item.update(name: "Tシャツ", price: 1800)
```

##### 解説
updateメソッドは、以下の流れで使用します。

1.変数に、更新したいレコードの情報を代入する。  
例では、Itemsテーブルのidが1番のデータを代入しています。

2.その変数に対してupdateメソッドを使用する。  
updateメソッドの引数には、変更後のデータをハッシュ形式で与えます。

#### ☀︎補足
updateの引数について

ハッシュは通常、以下のように「キー」と「バリュー」を波括弧で囲みます。  
　{ name: "Tシャツ", price: 1800 }  
　
そのため、これを引数にするなら本来は以下のように書きそうです。  
　@item.update( { name: "Tシャツ", price: 1800 } )  
しかし、Rubyではハッシュを引数で使う場合波括弧は省略できるため、省略して簡潔に書くのが一般的です。




#### 具体例１
```ruby
class UsersController < ApplicationController

  def update
    @user = User.find(params[:id])   
    @user.update(user_params)        # 2.Strong Parametersを通して更新
  end

  private
    def user_params
    
	  # これでセキュリティ的に「不要なカラム更新」を防げる。
      params.require(:user).permit(:name, :email)  # 1.userに許可するパラメータを限定
    end
end

```

データの流れ
1. **リクエスト受付**（PATCH /users/:id)
2. **更新対象をDBから取得**（`User.find(params[:id])`）
3. **Strong Parametersで安全な値だけ抽出**（`user_params`）
4. **updateで更新 & バリデーションチェック**
5. **結果に応じてリダイレクト or 再描画**

注意
- これだと「更新成功したかどうか」を判断できないので、**ユーザーにエラーを返せない**。
- 実際のアプリでは不親切になる。


#### 具体例２
```ruby
# バリデーションを考慮
def update
  @user = User.find(params[:id])
  if @user.update(user_params)
    redirect_to @user, notice: "ユーザーを更新しました"
  else
    render :edit, status: :unprocessable_entity
  end
end

private
	def user_params
      params.require(:user).permit(:name, :email)
    end

```


## update!

説明：
- ActiveRecord が提供する既存レコード更新メソッド
- `update` とほぼ同じ挙動で、**バリデーションを通過するかどうかを自動で確認してから更新が行われる**
- 違いは **失敗時に例外（`ActiveRecord::RecordInvalid`）を発生させる** 点
- 成功時は `true` を返す

基本形：`モデル.update！(ID=:all, 属性)`


## [[destroy]]

説明：
- `destroy` は **指定したレコードを削除するメソッド** 
- `delete` と違い、**バリデーションやコールバックを実行してから削除** 
- `dependent: :destroy` が設定されている場合は、**関連付けられたモデル（子レコード）も一緒に削除** 


#### 使用例
```ruby
基本形：`モデル.destroy(ID)`

article = Article.find(1)
article.destroy
# articlesテーブルのidが1のレコードを削除
```

#### 削除機能を実装するまでの流れ

1. ルーティングを設定
2. パスの指定
3. destroyアクションを定義
4. 削除するレコードのidの指定
5. レコードの削除

#### 1. ルーティングを設定


destroyメソッドは、destroyアクション内で使うのでdestroyアクションが動くルーティングを設定

routes.rb | ルーティング設定
```ruby
delete  'articles/:id'  => 'articles#destroy'
```

#### 2.パスの指定


ビューファイル内のdestroyアクションを動かすパスをarticles/#{item.id}と指定

ルーティングを定義したので、リンクもそのように記述
`:id`の部分にはarticleのidを入れたいので、`article.id`とする

ビューファイル | パスの指定
```
<%= link_to "削除", "articles/#{article.id}", method: :delete %>
```

#### 3.destroyアクションを定義


コントローラーのdestroyアクション内でdestroyメソッド

コントローラー | destroyアクションを定義
```ruby
def destroy
  article = article.find("削除するレコードのid")
  article.destroy
end
```

findメソッドの引数には削除するレコードのidが入る

今回はルーティングで「'articles/:id'」と指定
こう記述するとパスの`:id`に入っている値をコントローラーでは`params[:id]`とすることで取得できる

#### 4.削除するレコードのidの指定


コントローラーのdestroyアクションの引数に削除するレコードのidを指定

「'articles/:id'」の`:id`の部分はビューファイルでは「articles/#{article.id}」と記述
`params[:id]`としてあげれば削除したいレコードのidを取得できる

コントローラー | 削除するレコードのidの指定
```ruby
def destroy
  article = Article.find(params[:id])
  article.destroy
end
```

#### 5.レコードの削除


destroyメソッドが実行され、レコードが削除される。

これでidを指定できたので、findメソッドで削除したいレコードを取得
それを変数articleに代入し、articleにdestroyメソッドを使って指定したidのレコードを削除


## [[dsstroy!]]

説明：
`destroy!` は ActiveRecord が提供する **レコード削除用のメソッド**
読み方：「デストロイ・バン！」（ビックリマークがつくと「失敗したら例外を投げる」メソッドが多い）



## [[dependent]]


### 説明：

「親モデルが削除されたとき、子モデルをどうするか？」を決めるために使われる

### 具体例

例えば、以下のようなモデルがあったとする
```ruby
# article.rb
belongs_to :user

# user.rb
has_many :articles
```

このとき、usersテーブルのレコードが削除されたら
それに関連しているarticlesテーブルのレコードも削除しないとエラーが発生してしまう

なぜなら
idが5のユーザーが投稿した記事が10個あったとすると
idが5のユーザーを削除したらidが5のユーザーが投稿した記事が存在しているとおかしなことになる

これを解消するには
モデルで==dependentオプション==を定義する


```ruby
# user.rb
has_many :articles, dependent: :destroy
```

上のようにdestroyを定義すると
ユーザーが削除された際、それに関連するarticlesテーブルのレコードも同時にdestroyメソッドが実行され削除される


---



トランザクションとは？
データベースに対する **一連の処理を「ひとまとめ」にして、全部成功するか全部失敗するかを保証する仕組み**のこと

ロールバックとは？
失敗したときに処理を取り消して、データベースを元の状態に戻すこと


---


### Web技術の基本

#### [[HTTPリクエスト]]

説明：
クライアントからサーバーへのリクエストのこと

HTTPリクエストには
- リクエスト行
- HTTPヘッダー
- メッセージボディ　　の3つに分けることができる

具体例
```ruby
①
GET/index.html HTTP/1.1

②
Host: example.com
User-Agent: Moilla/5.0(Windows NT 6.1; Win64; x64)
Accept: text/html,application/xhtml+xml,applicaiton/xml
Accept-Encoding: gzip, deflate, sdch
Accept-Langage: ja,en-US;q=0.8,en;q=0.6
Connection: Keep-Alive

③

④

```

①リクエスト行：「Webサーバーに対して、どのような処理をして欲しいのか」という内容が記述されている
- HTTPメソッド：リクエストの目的を示す
- パス名：どのリソースにアクセスするか示す
- バージョン：HTTPのバージョンを示す

②HTTPヘッダー：リクエストやレスポンスに付ける追加情報（メタデータ）

③空白行：HTTPヘッダーの終わりを示す

④メッセージボディ：Webサーバに送るデータが記述されている


### [[HTTPレスポンス]]

説明：
サーバーからクライアントへのレスポンスのこと

HTTPレスポンスには
- ステータス行
- HTTPヘッダー
- メッセージボディ　　の3つに分けることができる

具体例
```ruby
①
HTTP/1.1 200 0K

②
Server: Apache
Date: Mon, 1 Jan 2024 00:00:00 GMT
Content-type: text/html; charset=UTF-8
Content-encoding: gzip

③

④

```

①ステータス行：WebブラウザにWebサーバー内での処理の結果が記述
- バージョン：HTTPのバージョンを示す
- ステータスコード：リクエストに対するWebサーバの結果を３桁の数字で示す
- テキストフレーズ：ステータスコードの内容をテキストで示す

②HTTPヘッダー：リクエストやレスポンスに付ける追加情報（メタデータ）

③空白行：HTTPヘッダーの終わりを示す

④メッセージボディ：HTMLや画像などのデータを格納する場所

補足
`name=test&pass=123`
- `&` で区切られている → 複数のデータが並んでいる
- `key=value` 形式 → 「キーと値のペア」
    

具体的には：
- `name` というキーに `test` という値を入れる
- `pass` というキーに `123` という値を入れる

👉 つまり「ユーザー名は test」「パスワードは 123」という意味。


---


## 学んだこと

- updateとupdate!について
- destroyとdestroy!について
- HTTPリクエストとHTTPレスポンス
- ここには書いてませんが、Railsガイドにてマイグレーション関連の内容を調べ直してました


---


## 教材

- RUNTEQ「基礎：基礎STEP 総復習」
- スッキリわかるSQL入門 第4版
- Web技術の基本 第2版


---


##### ⏳ 学習時間: 6.8時間  
##### 🌱 コミット数: 1コミット