### What：N+1問題とは何か？

DBへのクエリが不必要に発生してしまうパフォーマンスの問題のこと！
ORMを使用するときに発生するアンチパターンのこと

具体的には、以下のような流れで発生します。 

1. **1回目のクエリ**: 関連データを持つレコードのリストをまとめて取得する。
2. **N回のクエリ**: 取得したリストの各レコードに対して、関連データを個別に取得するためのクエリをN回実行する。

例えば、1人のユーザーが複数の記事を投稿できるアプリケーションを考えます。

- **1回目のクエリ**: `SELECT * FROM users;` (ユーザー100人分のリストを取得)
- **N回のクエリ**: 各ユーザーが投稿した記事を取得するため、ユーザー1人ごとに `SELECT * FROM posts WHERE user_id = ?;` というクエリを100回実行する。 

結果として、合計で1+100=101回のクエリが発生し、これがN+1問題と呼ばれます。 


### Why：なぜN+1問題が発生するのか？

N+1問題が発生する主な理由は、**ORMが「関連データの遅延読み込み（Lazy Loading）」をデフォルトで行う**ことにあります。 

- **ORMの抽象化**: ORMはデータベースのテーブルとプログラムのオブジェクトをマッピングすることで、データベース操作を単純化してくれます。開発者は、関連データにアクセスしようとするだけで、ORMが自動で適切なクエリを実行してくれるため、詳細な実装を意識する必要がありません。
  
- **遅延読み込み**: このとき、多くのORMは関連データをすぐに取得せず、**そのデータが実際に必要になったタイミング（アクセスされたタイミング）で初めてデータベースに問い合わせる**という仕組みを採用しています。
  
- **非効率なループ**: 上記のユーザーと記事の例では、ユーザーリストをループで回しながら、そのループの中でユーザーごとの記事を取得しようとすると、ループが回るたびにORMがデータベースにクエリを発行します。これがN+1問題の直接的な原因です。 

### How：どうすればN+1問題を解決できるか？

N+1問題を解決する最も一般的な方法は、**「先行読み込み（Eager Loading）」**と呼ばれる手法です。 

- **JOINを使う**: 関連データを1つのSQLクエリでまとめて取得します。ORMの機能で `JOIN` を使用するよう指定することで、複数のテーブルを結合して必要なデータを一度に取得できます。
  
- **バッチ処理**: 大量のデータを一括で取得し、アプリケーション側で関連付けを行います。`IN`句を使って、複数のIDに対応する関連データをまとめて取得するなどの方法があります。
  
- **ORMの機能を使う**: 各ORMにはN+1問題の対策機能が用意されています。
    - **Ruby on Rails**: `includes`⭐️
    - **Django**: `select_related` または `prefetch_related`
    - **Spring/JPA**: `@ManyToOne` または `fetch = FetchType.EAGER`、`JOIN FETCH` 


### So What：だから何？解決しないとどうなる？

N+1問題を放置すると、アプリケーションのパフォーマンスに深刻な影響を与え、ビジネス上の問題に発展する可能性があります。 

- **応答時間の遅延**: クエリの数が多ければ多いほど、データベースとの通信回数が増え、結果としてWebページの表示速度やAPIの応答速度が低下します。これはユーザーエクスペリエンスの悪化につながります。
  
- **データベースへの負荷増大**: 大量かつ不要なクエリがデータベースに集中することで、データベースサーバーに過剰な負荷がかかります。これにより、他の正常な処理にも遅延が発生したり、最悪の場合、サーバーがダウンしたりする可能性があります。
  
- **スケーラビリティの低下**: データ量が増えるにつれて、N+1問題によるパフォーマンス劣化も指数関数的に悪化します。ユーザー数やデータが増加した場合に、アプリケーションがスケールしにくくなります。
  
- **開発コストの増加**: 問題が深刻化してから対処しようとすると、改修にかかるコストや工数が大きくなります。早期にN+1問題を意識し、適切なコーディングを行うことが、長期的な開発効率の向上につながります。



### 補足

原因：
```ruby
# users_controller.rb
def index
  @users = User.all
end

# index.html.erb
<% @users.each do |user| %>
  <p><%= user.name %></p>
  <% user.posts.each do |post| %>
    <li><%= post.title %></li>
  <% end %>
<% end %>

```

解説：
1. User.allは、全ユーザーを取得するクエリを実行する
	1. ex) SELECT * FROM users;
2. 各ユーザーは、user.postsを参照するたびに、そのユーザーの記事を取得するクエリが発行されている（10人なら10回のクエリ）
	1. SELECT * FROM posts WHERE user_id = 1;
3. 合計、1 + 10 = 11回のクエリが発行される
	1. つまり、N + 1 問題（Nはユーザーの数）


解決策：
Railsでは `includes` を使うのが一般的
```ruby
@users = User.includes(:posts).all
```

解説：
1. この時点では Rails は`SELECT * FROM users;`だけを最初に実行
	1. 全ユーザーの情報しか取得していない
	   
2. user.postsに触れた瞬間、`SELECT * FROM posts WHERE user_id IN (1,2,3,...);`という形のクエリを発行
	1. ここで、関連する全ユーザーの投稿を **一括で取得**
3. 合計２回のクエリが発行される

補足
- **includesは「関連モデルをまとめて読み込む準備」をするだけ**　
	- Rails (ActiveRecord) が提供する **メソッド**

- 実際の `posts` 取得は **ビューで `user.posts` にアクセスしたとき** に発生する
- そのときに **N回発行する代わりに、まとめて1回のIN句で取得する**

