#daily

## 今日取り組んだタスク

- [ ] 中間試験：Ruby
- [ ] 中間試験：SQLとデータベースの改善
- [ ] Web技術の基本

---
---
## 一言

レビューが返ってきたのですが、見事に最後の課題間違えてましたねw
しっかりと課題に書かれていることを確認して、作業することが大事だと痛感しまいたorz
反省です💦

---
---
## 学習内容

## SQL

```

---
## SQL

#### 2025年を指定した場合

```sql
WHERE from_date <= '2025-12-31' AND to_date >= '2025-01-01'
```

例: レコードの期間

|レコード|from_date|to_date|2025年との関係|
|---|---|---|---|
|A|2024-12-01|2025-02-28|2025年と重なる ✅|
|B|2025-03-01|2025-06-30|2025年と重なる ✅|
|C|2025-12-01|2026-02-28|2025年と重なる ✅|
|D|2024-01-01|2024-12-31|2025年と重ならない ❌|
|E|2026-01-01|2026-12-31|2025年と重ならない ❌|

図で見ると

```
`2025年: |----2025-01-01-------------2025-12-31--------------------------------|  

A: |----2024-12-01----2025-02-28----| ✅ 
B:             |----2025-03-01----2025-06-30----| ✅ 
C:                        |----2025-12-01----2026-02-28----| ✅ 
D: |----2024-01-01----2024-12-31----| ❌ 
E:                                    |----2026-01-01----2026-12-31----| ❌`
```
💡 ポイント

- 「from_date が 2025-12-31 以前」かつ「to_date が 2025-01-01 以降」で **少しでも2025年にかかるものすべて** が抽出される。
    
- 2025年に完全に入っていなくてもOK。



---
## Git

#### コミットメッセージの内容の変更

```bash
### まだプッシュしていない場合（ローカルのみ）

# 最新のコミットメッセージを修正
git commit --amend -m "新しいコミットメッセージ"
```

```bash
### 既にプッシュ済みの場合

# コミットメッセージを修正
git commit --amend -m "新しいコミットメッセージ"

# 強制プッシュ（注意が必要）
git push origin ブランチ名 --force

```


#### 一度マージ済みのブランチを再度編集することは推奨されていない

🧠 前提

「マージ済み」というのは、  
たとえば `feature/1_SQL` ブランチを `main` に `merge` した状態、ということですね。

この時点で、`main` に「ブランチの変更内容」は取り込まれています。



基本的に避ける理由

1. **履歴が複雑化する**  
    すでに取り込まれた内容を再編集すると、後から「どの変更が最終なのか」がわかりづらくなります。
    
2. **再マージ時にコンフリクトが発生しやすい**  
    同じブランチを再度マージすると、`main` との整合性が崩れることが多いです。
    
3. **「過去の作業ブランチ」は記録として残すのが普通**  
    1つのブランチは「1つの目的（機能や修正）」に対応しておくと、履歴がきれいでチームでも分かりやすいです。


✅ 正しい（推奨される）やり方

もしマージ済みブランチの内容を**さらに修正したい**なら…

- **新しいブランチを作る** のが基本です。
    
    `git checkout main git pull git checkout -b fix/sql_tweak`
    そして修正して、再度 `main` にマージします。



---
## web技術の基本

HTTP/2

Webの高速化と効率化を実現するための主要な機能

- ストリームによる多重化
説明：
この機能は、1つのTCPコネクションでリクエストとレスポンスを同時にやり取りする技術のことです


ストリームの多重化（Multiplexing）

1つのTCPコネクションで、複数のリクエストとレスポンスを同時にやり取りする技術です。 

- **HTTP/1.1の課題:** HTTP/1.1では、複数のリソース（画像、CSS、JavaScriptなど）を取得する際に、複数のTCPコネクションを張るか、順番に処理する必要がありました。これにより、通信の待ち時間（Head-of-Line Blocking）が発生し、Webページの表示速度が低下していました。
- **HTTP/2での解決:** 複数のリクエストとレスポンスを細切れの「フレーム」に分割し、1つのTCPコネクション上で送受信します。これにより、複数のリソースを並行してダウンロードでき、通信効率が大幅に向上します。 

バイナリ形式の利用

HTTP/2の通信メッセージは、人間が読めるテキスト形式ではなく、機械が効率的に処理できるバイナリ形式で送受信されます。 

- **HTTP/1.1の課題:** HTTP/1.1はテキストベースのプロトコルであり、パース（解析）処理にコストがかかるほか、無駄なスペースや改行などが通信量を増加させていました。
- **HTTP/2での解決:** バイナリ形式にすることで、より高速かつ効率的なパースが可能になり、通信オーバーヘッドが削減されます。 

ヘッダー圧縮

リクエストとレスポンスのヘッダー情報を圧縮する技術です。 

- **HTTP/1.1の課題:** 多数のリクエストを送信する際、同じようなヘッダー情報（ユーザーエージェント、クッキーなど）が毎回送られ、通信のオーバーヘッドが大きくなっていました。
- **HTTP/2での解決:** HTTP/2専用の圧縮アルゴリズムである**HPACK**を使用し、重複するヘッダーをインデックス参照で送信することで、データ量を大幅に削減します。 

サーバープッシュ（Server Push）

クライアントからのリクエストを待たずに、サーバー側から必要と予測されるリソース（CSS、JavaScriptなど）を事前に送信する機能です。 

- **HTTP/1.1の課題:** クライアントはHTMLをダウンロードしてから、そのHTMLに記述されているCSSやJavaScriptを**発見**し、**再度リクエスト**する必要がありました。
- **HTTP/2での解決:** クライアントがHTMLをリクエストした時点で、サーバーは必要な他のリソースも同時にプッシュできます。これにより、クライアントは追加のリクエストを待つことなくリソースを取得でき、ページのレンダリングが高速化されます。
    - **現在の状況:** サーバープッシュは、クライアントにキャッシュが存在する場合に無駄になるなどの課題があり、主要なブラウザでの実装が削除されたり、利用が推奨されなくなったりしています。代替技術として、HTTPヘッダーの`103 Early Hints`が使われるようになってきています。



---
---
## 学んだこと

- HTTP/2の機能について
- コミットコメントの改善


---
---
## 教材

- web技術の基本
- 中間試験
- paiza


---
---
##### ⏳ 学習時間: 5.8時間  
##### 🌱 コミット数: １コミット