
---

# RSpec モデルバリデーションチェック学習メモ

## ✅ コード例

```ruby
RSpec.describe Task, type: :model do
  describe 'バリデーションチェック' do
    it '設定したすべてのバリデーションが機能しているか' do
      user = User.create(email: "user@example.com", password: "password")
      task = user.tasks.new(title: "abc", content: "abcdefg", status: :todo)
      expect(task).to be_valid
      expect(task.errors).to be_empty
    end
  end
end
```

---

## 🔹 意識すべきポイント

### 1. アソシエーションを意識する

```ruby
user = User.create(email: "user@example.com", password: "password")
task = user.tasks.new(...)
```

* `Task` が `User` に属している（`belongs_to :user`）ため、まずユーザーを作成してから `task` を紐付けている。
* **親子関係が正しく作られているか**を意識する。
補足
- `user.tasks`
  - User モデルに has_many :tasks が定義されている前提。
  - user.tasks は「そのユーザーに紐づく Task 達（コレクション）」を表す。
  - 👉 user が親で、その子である tasks 一覧を取っているイメージ。
---

### 2. 必須属性をすべて揃える

```ruby
task = user.tasks.new(title: "aaa", content: "aaa", status: :todo)
```

* モデルのバリデーションで必須な属性をきちんと埋める。
* **「この入力なら有効になる」最小限の条件**を満たすことを意識する。

補足
- 属性（attribute）は、モデルのインスタンスが持つ値のこと
- 基本的にはDBのカラムと1対1で対応する
- なので「属性＝カラム」と考えてOKだけど、文脈によっては Railsで扱う値 を強調するときに「属性」という言葉を使う

---

### 3. `be_valid` で有効性を確認

```ruby
expect(task).to be_valid
```

* `task.valid?` が `true` であることを確認。
* **バリデーションが正しく通っているか**をチェックしている。

---

### 4. `errors` が空であることを確認

```ruby
expect(task.errors).to be_empty
```

* バリデーションを通過した場合はエラーが出ていないはず。
* **成功（valid）と同時に、エラーがないことを保証**している。

---

### 5. テストの意図を明確にする

* この例は「必要な項目をすべて入力すれば有効になる」ことをまとめて確認するテスト。
* 実際の現場では「titleがないと無効」「contentがないと無効」などを **1つずつテストする**ことも多い。
* ここでは **全体のバリデーションが正しく働いているかの最終チェック**として理解できる。

---

## ✅ 学習ポイントまとめ

* アソシエーションを意識して親レコード（User）を先に作成する
* 必須属性をすべて埋めて「有効になる最小条件」を意識する
* `be_valid` で「バリデーション成功」を確認
* `errors` が空かどうかをセットでチェックする
* テストの目的（全体チェックか、個別チェックか）を明確にする

---
```ruby
RSpec.describe Task, type: :model do
  describe 'バリデーションチェック' do
    it 'titleが被らない場合は有効であること' do
      # 先に1件保存しておく
      Task.create!(title: "テスト1", content: "内容1", status: :todo)

      # 別のtitleで新しいTaskを作成
      task = Task.new(title: "テスト2", content: "内容2", status: :todo)

      # バリデーションエラーが起きないことを確認
      expect(task).to be_valid
      expect(task.errors).to be_empty
    end
  end
end
```

---

# 🔹 1. `Task.create!(title: "テスト1", ...)`

* **処理内容**

  * オブジェクトを作成して、**同時にデータベースへ保存**する
  * 末尾の `!` が付いているので、もしバリデーションに失敗したら **例外（エラー）を投げる**

* **データの流れ**

  1. `Task` のインスタンスを生成
  2. バリデーションを実行
  3. OKならDBに保存（レコードが追加される）
  4. NGなら `ActiveRecord::RecordInvalid` 例外を発生

* **例**

  ```ruby
  Task.create!(title: "テスト1", content: "内容1", status: :todo)
  ```

  → DBに「title=テスト1」のレコードが保存される。

---

# 🔹 2. `task = Task.new(title: "テスト2", ...)`

* **処理内容**

  * オブジェクトを作成するだけで、**まだDBには保存されない**
  * バリデーションも走らない（`valid?` や `save` を呼ぶまで実行されない）

* **データの流れ**

  1. `Task` のインスタンスを生成
  2. まだバリデーションは未実行
  3. `task.valid?` を呼ぶとバリデーション実行
  4. `task.save` を呼ぶと保存される（バリデーションNGなら保存されない）

* **例**

  ```ruby
  task = Task.new(title: "テスト2", content: "内容2", status: :todo)
  task.valid?  # => true
  task.persisted? # => false （まだDBに保存されていない）
  task.save   # => true （ここで初めてDBに保存される）
  ```

補足
🔹 save メソッドの処理の流れ

- バリデーションを実行
  - モデルに定義した validates ... がすべてチェックされる
  - NGなら保存されない
- 保存処理（INSERTまたはUPDATE）
  - バリデーションに通ったら、DBに実際のSQLが発行される
    - 新規 (new) の場合 → INSERT
    - 既存 (find などで取ってきた) の場合 → UPDATE
- 返り値
  - 成功したら true
  - 失敗したら false

いいところに注目しました！🙆‍♂️
`expect(task).to be_valid` と `expect(task.errors).to be_empty` は、見た目は似ていますがチェックしているものが少し違います。

それぞれ **データの流れ → 必要性 → 処理内容** の3点で整理します。

---

# 🔹 3. `expect(task).to be_valid`

### ✅ データの流れ

1. `task.valid?` が内部的に呼ばれる
2. モデルに定義された **バリデーションがすべて実行される**
3. 問題がなければ `true`、エラーがあれば `false` が返る

### ✅ 必要性

* **このインスタンスは保存できる状態か？** を確かめたいときに必須
* バリデーションを通ること自体がテストの目的

### ✅ 処理内容

* 実際には `be_valid` は RSpec のマッチャーで、

  ```ruby
  expect(task.valid?).to eq(true)
  ```

  と同じ意味
* バリデーションが有効に動作しているかを確認する

---

# 🔹 4. `expect(task.errors).to be_empty`

### ✅ データの流れ

1. `task.valid?` が既に呼ばれている場合、エラー情報が `task.errors` に入っている
2. `task.errors` はエラーの一覧を持つオブジェクト（ActiveModel::Errors）
3. エラーが1件もなければ空のコレクションを返す

### ✅ 必要性

* バリデーションに通ったとき **エラーが記録されていないことを保証**する
* `be_valid` だけだと「true/false」でしか見えない
* `errors` をチェックすることで「本当にエラー配列が空か？」を追加で確認できる

### ✅ 処理内容

* 実際には

  ```ruby
  expect(task.errors.empty?).to eq(true)
  ```

  と同じ意味
* バリデーションOKなら `task.errors` は空 → テスト成功

---

# 🔹 両方書く意味

* `be_valid` → バリデーションを通るかどうか（結果の真偽）
* `errors.empty?` → エラー詳細が残っていないか（二重チェック）

👉 `be_valid` だけでも基本的には十分ですが、**`errors` も確認すると「本当にエラーが空か？」が保証されるので、より堅牢なテスト**になります。



---

# 🔹 違いをまとめる

| 書き方            | DB保存  | バリデーション実行                  | エラー時の挙動               |
| -------------- | ----- | -------------------------- | --------------------- |
| `Task.create!` | 即保存する | 実行される                      | 例外を投げる                |
| `Task.new`     | 保存しない | 実行されない（`valid?`や`save`で実行） | エラーは出ない（ただの未保存インスタンス） |

---

# ✅ まとめ

* **`create!`** = 「インスタンスを作って即保存。失敗したら例外」
* **`new`** = 「インスタンスを作るだけ。保存は別途 `save`」

👉 テストでは、**比較用のレコードを確実にDBに作りたいときは `create!`**
👉 **検証用のオブジェクトを作って様子を見たいときは `new`** を使うのが基本です。

---
