#daily

## 今日取り組んだタスク

- [ ] ミニアプリの環境構築
- [ ] スッキリわかるSQL入門
- [ ] skill matrix 

---
---
## 一言

今まで、全く手をつけていなかったskill matrix をやりましたが
5つのうち、3つは例のブラウザのエラー表示だったり、画面が暗くなってしまい、三日後に受ける羽目になりやした......

やっちゃったぜ！！！
三日後は、windows PCで受けます.......

この問題も放置すべきではないことを今日痛感しました.....

---
---
## 学習内容

### Rails


#### 開発中にGemfileを編集して、新しいGemを追加したいなら
```
docker compose run --rm web bundle install
```

補足
`docker compose exec`コマンドでも実行できるが、`run`の場合は新たにコンテナを立ち上げるため
bundle installをした場合

それが「既存の実行中のコンテナの状態によるもの」なのか
それとも「基本的なイメージやGemfile、またはそのコマンド自体に起因するもの」なのかを区別しやすくなる
つまり、runは新しい環境で実行できる

また、gemfileを編集したので、`docker compose build`をしてイメージを再構築する必要がある
その後、新しいイメージでコンテナを起動する


### Taskモデルを作成したいなら
→`docker compose run --rm web rails generate model Task`

流れ
1. **Docker Composeを通じて、`web`サービスコンテナを一時的に起動する**
2. **そのコンテナ内で、`rails generate model Task`コマンドを実行する**
3. **コマンド実行後、コンテナを自動的に削除する**

※これにより、Docker環境に汚染を残さず、クリーンな状態でRailsのモデル生成作業を行う

補足
- `Task`モデルを定義する`app/models/task.rb`ファイル
- データベースに`tasks`テーブルを作成するためのマイグレーションファイル
などが生成される！

### Taskモデルを作成後、生成された一連のファイルを削除したいなら
→`docker compose run --rm web rails destroy model Task`

⬇️以下コピペ⬇️
流れ
1. **Docker Composeによるコンテナ起動**
2. **`web`コンテナ内部でのコマンド実行**
    - Dockerデーモンは、`web`コンテナの環境内で`rails destroy model Task`コマンドを実行します。
    - このコマンドが、`rails generate model Task`によって生成されたファイルを探します。具体的には、以下のファイルが対象となります。
        - `app/models/task.rb`
        - `db/migrate/[タイムスタンプ]_create_tasks.rb`
        - `test/models/task_test.rb`（または`spec/models/task_spec.rb`）
        - `test/fixtures/tasks.yml`
3. **ファイルの削除**
    - `rails destroy`コマンドは、上記のファイルがプロジェクト内に存在することを確認し、順次削除します。
    - コマンドの実行中、どのファイルが削除されたかを示すメッセージがターミナルに表示されます。
4. **コンテナの停止と削除**
    - `rails destroy`コマンドが正常に終了すると、コンテナが停止します。
    - `--rm`オプションのおかげで、停止したコンテナはディスクから自動的に削除されます。これにより、一時的な作業で作成された不要なコンテナが残ることはありません

### Taskモデルにバリデーションとメソッドを追加した段階でのデバッグ

１：Railsコンソールを起動
```
docker compose run --rm web rails console
```

２：基本的なオブジェクトを作成してテスト（以下ただのサンプル）
```ruby
# コンソール内で実行

# 1. 正常なTaskオブジェクトの作成
task = Task.new(title: "サンプルタスク", description: "テスト用のタスクです", priority: 2)
task.valid?
# => true が返ってくればOK

# 2. 保存テスト
task.save
# => true が返ってくればOK

# 3. 保存されたデータの確認
Task.last
# => 先ほど作成したタスクが表示される

など
```

３：バリデーションのテスト
```ruby
# タイトルが空の場合のテスト
invalid_task = Task.new(description: "説明のみ")
invalid_task.valid?
# => false が返ってくればOK

# エラーメッセージの確認
invalid_task.errors.full_messages
# => ["Title can't be blank"] のようなメッセージが表示される

# 優先度が範囲外の場合のテスト
invalid_priority = Task.new(title: "テスト", priority: 5)
invalid_priority.valid?
# => false が返ってくればOK

invalid_priority.errors.full_messages
# => 優先度のエラーメッセージが表示される

など
```

４：カスタムメソッドのテスト
```ruby
# 完了状態のテスト
task = Task.create(title: "完了テスト", completed: true)
task.completed?
# => true が返ってくればOK

# 優先度テキストのテスト
task1 = Task.create(title: "低優先度", priority: 1)
task1.priority_text
# => "低" が返ってくればOK

task2 = Task.create(title: "中優先度", priority: 2)
task2.priority_text
# => "中" が返ってくればOK

task3 = Task.create(title: "高優先度", priority: 3)
task3.priority_text
# => "高" が返ってくればOK

# 優先度未設定のテスト
task4 = Task.create(title: "未設定", priority: nil)
task4.priority_text
# => "未設定" が返ってくればOK
```


---
### SQL

**AND演算子**

説明：
2つの条件式が真であれば、真となる演算子

基本文
`条件式 AND 条件式2`

**OR演算子**

説明：
2つの条件式のどちらかが真であれば、真となる演算子

基本文
`条件式1 OR 条件式2`

補足
これらの演算子は、論理演算子と呼ばれている
また、論理演算子には優先度が存在しており、NOT > AND > OR の順で大きい
（）で優先順位を指定することも可能である

テーブル「田中くんの買い物リスト」

| カテゴリ | 名称              | 販売店 | 価格   |
| ---- | --------------- | --- | ---- |
| ゲーム  | スッキリ勇者クエスト      | B   | 7140 |
| ゲーム  | スッキリ勇者クエスト      | Y   | 6850 |
| 書籍   | 魔王討伐日誌          | A   | 1200 |
| DVD  | スッキリわかるマンモスの倒し方 | A   | 5250 |
| DVD  | スッキリわかるマンモスの倒し方 | B   | 7140 |

リスト3-7：2つの条件式を組み合わせる（B店のスッキリ勇者クエストの価格を6280に更新したい）


```sql
UPDATE 田中くんの買い物リスト
SET 価格 = 6280
WHERE 名称 = 'スッキリ勇者クエスト'
AND 販売店 = 'B'
```

補足
ここで、販売店B店以外の行としたいなら
`AND NOT 販売店 = 'B'`

また、`AND 販売店 <> 'B'`などの書き方もある


リスト3-9：論理演算子の優先順位を指定する（販売店がAかBが売っている、ゲームかDVDの行を取得）


```sql
SELECT *
  FROM 田中くんの買い物リスト
 WHERE (販売店 = 'A'
    OR 販売店 = 'B')
   AND (カテゴリー = 'ゲーム'
    OR カテゴリー = 'DVD')


```


---
### Web技術の基本

**IPアドレス**

説明；
インターネットに接続されたコンピューターを特定するための識別番号のこと
コンピューターに割り当てられたIPアドレスを指定することで、特定のコンピューターへ接続ができる
住所のような役割を持つ

役割：
ネットワークの個々のコンピューターを識別するための住所



**ポート番号**

説明：
コンピューター内部では、Webサービスやメールサービスのような様々なサービスを提供しており
ポート番号は、それらを指定するためのもの
IPアドレスは住所で、ポート番号は部屋番号のようなものだとよく例えられている

役割：
IPアドレスを特定されたコンピューターの中で、どのアプリケーションが通信を行うかを識別する窓口

---
### Docker

```ruby
docker compose run --rm web rails new . --force --database=sqlite3

# この時点では：
# ✅ Railsファイルが生成される
# ❌ Webサーバーは起動しない
# ❌ localhost:3000にはアクセスできない
```

### 解説

**各部分の意味**
**`docker compose run`**
- Docker Composeを使って **一時的なコンテナを起動** し、その中でコマンドを実行
- `docker compose up` とは違って、**一回限りの実行** のためのコマンド

 **`--rm`**
- **コマンド実行後にコンテナを自動削除**
- 一時的な作業用なので、実行後は不要になるため自動でクリーンアップ
- これがないと使い捨てコンテナが溜まってしまう

**`web`**
- **docker-compose.ymlで定義したサービス名**
- あなたの場合、Railsアプリケーション用のサービスを`web`と名付けている

 **`rails new .`**
- **現在のディレクトリ（`.`）にRailsアプリケーションを新規作成**
- 通常は `rails new my_app` のようにディレクトリ名を指定するが、`.` で現在の場所に作成

 **`--force`**
- **既存ファイルを上書き**
- すでに `Gemfile` や `docker-compose.yml` などがある場合、それらを上書きして進める
- これがないと「ファイルが既に存在します」というエラーで止まる

 **`--database=sqlite3`**
- **データベースにSQLite3を指定**
- デフォルトでもSQLite3だが、明示的に指定している


このコマンドによって：

- **新しい`Gemfile`が生成された**
- Railsアプリケーションに必要なgemの一覧が更新された
- 既存の`Gemfile`が上書きされた（`--force`により）

**現在のDockerイメージの状態**
- **古い`Gemfile`に基づいてビルドされている**
- 新しい`Gemfile`の内容が反映されていない
- 必要なgemがインストールされていない可能性がある


---
---
## エラーと対応

- エラー内容：ERROR (web 56) RUN bundle install
```ruby
 => ERROR [web 5/6] RUN bundle install                                                                        0.3s 
------                                                                                                             
 > [web 5/6] RUN bundle install:
0.307 Your Ruby version is 3.1.7, but your Gemfile specified 3.1.0
------
failed to solve: process "/bin/sh -c bundle install" did not complete successfully: exit code: 18
```

### エラーの原因

DockerイメージのRubyのバージョンが3.1.7であるが、GemfileのRubyのバージョンは3.1.0なので
ここでバージョンの不一致が起こっている


### 解決策

- 対処方法：DockerfileとgemfileのRubyのバージョンを一致させること！

#### 補足
Dockerfile: `FROM ruby:3.1` → 実際には3.1.7を使用（自動で最新版）
Gemfile: `ruby "3.1.0"` → 不一致

#### 注意点
将来的に Docker Hub 上の `ruby:3.1` が `3.1.8` に更新されると、  
同じDockerfileでも別バージョンのRubyでビルドされる可能性がある

それを防ぐには**完全固定するのが安全策** 👇
`FROM ruby:3.1.7`
これで将来3.1.8が出ても常に3.1.7を使い続ける

---
### Git

### 📋 ブランチ名の命名規則

##### **プレフィックスの種類**

- `feature/` - 新機能開発
- `fix/` - バグ修正
- `refactor/` - リファクタリング
- `docs/` - ドキュメント更新

補足
==**ある文字列やコードの先頭に付加される識別子**==のこと

---
---
## 学んだこと

Docker
- 新しいgemを追加した場合の対応
- docker compose runの理解
- dockerのイメージとgemfileの関係
Web技術の基本
- IPアドレス
- ポート番号
SQL
- AND演算子
- OR演算子
Ralis
- Taskモデルを作成したいなら
	- `docker compose run --rm web rails generate model Task`
- Taskモデルを作成後、生成された一連のファイルを削除したいなら
	- `docker compose run --rm web rails destroy model Task`
- Taskモデルを作成後、バリデーションやメソッドを追加した時のデバッグの意識


---
---
## 教材

- web技術の基本
- スッキリわかるSQL入門



---
---
##### ⏳ 学習時間: 5.6時間  
##### 🌱 コミット数: １コミット