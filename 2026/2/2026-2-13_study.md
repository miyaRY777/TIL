# request.get? を入れる理由とは？


## 結論

`request.get?` を入れる理由は、**「安全な戻り先だけを保存するため」**です。  
GET以外（POST/PUT/PATCH/DELETE）は**処理を実行するリクエスト**なので、保存すると事故が起きます。

---

## 理由

GETは基本的に「表示するだけ」です。  
同じURLに戻っても、何度開いても問題が起きにくいです。

一方でPOST/PUT/PATCH/DELETEは「作成・更新・削除」を実行します。  
これを「ログイン後の戻り先」として保存すると、ログイン後に**同じ処理が再実行**される可能性があります。  
結果として、二重登録や二重更新などの不具合につながります。

だから **戻り先として保存するのはGETだけ** にします。

---

## 具体例

未ログインで「プロフィール作成（POST）」を送ったケースを考えます。

1. ユーザーが未ログインで `POST /profiles` を送る（作成処理）
    
2. ログイン画面へリダイレクトされる
    
3. もしPOSTを「戻り先」として保存していたら…
    
4. ログイン後に `POST /profiles` が再実行されるかもしれない
    
5. **プロフィールが二重作成**される危険がある
    

だから、保存対象をGETに限定するために `request.get?` を使います。

---

## 結論

`request.get?` は、**ログイン後に安全に戻れるページだけを記録するための条件**です。  
処理を再実行してしまう事故を防ぐために、GET以外は保存しない設計にします。

# 戻り先とは？



## 結論

「戻り先」とは、**ログインが必要なページに未ログインで来たときに、ログイン後に戻すページ（URL）**です。  
ユーザーを迷子にしないために、事前にURLを保存しておきます。

---

## 理由

未ログインでアクセスすると、アプリはログインページへ移動させます。  
このとき戻り先がないと、ログイン後にトップページなどへ飛ばされてしまいます。  
するとユーザーは「さっき何を見ようとしてたんだっけ？」となります。  
だから、元々見たかったページのURLを保存し、ログイン後にそこへ戻す仕組みが必要です。

---

## 具体例

ユーザーが未ログインでプロフィール詳細を開こうとする例です。

1. 未ログインで `GET /profiles/1` にアクセス
    
2. ログインページへリダイレクトされる
    
3. 同時に「戻り先」として `/profiles/1` を保存する
    
4. ログイン成功後、保存していた `/profiles/1` にリダイレクトして戻す
    

保存はたとえば次のように行います。

```ruby
store_location_for(:user, request.fullpath)
```

これは「今のURLを、ログイン後の戻り先として覚えておく」という意味です。

---

## 結論

戻り先は、**ログインを挟んでもユーザーの目的地を保つためのURLメモ**です。  
「ログインしたら、さっき見たかったページに戻れる」を実現するために使います。

# is_navigational_format? はなぜ必要なの？



## 結論

`is_navigational_format?` が必要なのは、**「人がブラウザで見る画面（HTML）のときだけ戻り先を保存する」ため**です。  
JSONなどのAPI通信まで保存すると、ログイン後の遷移が壊れて使いにくくなります。

---

## 理由

アプリには2種類のアクセス（アクセス）があります。

- **画面遷移（HTML）**：ユーザーがページを開く
    
- **データ通信（JSONなど）**：JavaScriptや外部アプリが裏で叩く
    

戻り先（保存するURL）は、基本的に「次に表示したいページ」です。  
つまり **画面遷移（HTML）だけが対象**です。

もしJSONの通信まで保存すると、ログイン後に

- 画面ではなく **JSONのURLへリダイレクト**される
    
- ブラウザに **JSONがそのまま表示**される
    
- Turbo/JSの通信が混ざって **意図しないページに飛ぶ**
    

といった“変な挙動”になります。

だから `is_navigational_format?` で「ナビゲーション用の形式だけ」を選びます。

---

## 具体例

例：プロフィール画面が未ログインで開けない場合

- ユーザーが `GET /profiles/1`（HTML）を開く  
    → ログイン後、同じページに戻れる（OK）
    

一方で、画面の中でJSが裏で

- `GET /profiles/1.json`（JSON）を取得していた場合  
    → これを保存してしまうと、ログイン後に **/profiles/1.json** に飛ぶ  
    → 画面ではなくJSONが表示されて「バグっぽい」体験になる（NG）
    

`is_navigational_format?` は、この事故を防ぎます。

---

## 結論

`is_navigational_format?` は、**戻り先を「人が見る画面（HTML）」に限定するため**に必要です。  
API通信や裏側の通信を保存しないことで、ログイン後の遷移を安全で分かりやすく保てます。

# request.xhr?はなぜ必要なの？


## テーマ

request.xhr?について

---

## 結論

`request.xhr?` は、  
**その通信がAjax（裏側の非同期通信）かどうかを判定するメソッド**です。

Ajax通信を通常の画面遷移と区別するために使います。

---

## 理由

Ajax通信は「画面を移動するためのリクエスト」ではありません。  
ページの一部だけを裏で更新するための通信です。

そのため、

- 戻り先として保存してはいけない
    
- 通常の画面遷移と同じ扱いをしてはいけない
    

という場面があります。

特にログイン後のリダイレクト処理では重要です。  
AjaxのURLを保存すると、意図しないページに飛んでしまいます。

---

## 具体例

```ruby
def storable_location?
  request.get? &&
    is_navigational_format? &&
    !devise_controller? &&
    !request.xhr?
end
```

この `!request.xhr?` は、

「Ajax通信なら戻り先として保存しない」

という意味です。

例えば、

- 未ログインで `/profiles` にアクセス
    
- そのページ内で「いいね」ボタンを押す（Ajax）
    
- そのAjaxのURLが戻り先に保存される
    

すると、ログイン後にJSONのURLへ飛ぶ可能性があります。

これを防ぐために `!request.xhr?` を使います。

---

## 結論

`request.xhr?` は、  
**Ajax通信かどうかを判定するためのメソッド**です。

画面遷移だけを正しく扱うために、  
Ajax通信を除外する目的で使われます。