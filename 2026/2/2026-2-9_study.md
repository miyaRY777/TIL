# Profile編集はProfileだけ、nickname更新はDevise側だけ起きる

## 結論

Profile編集画面で更新できるのは **Profileの項目だけ**です。  
`nickname` が **Userのカラム**なら、更新は **Deviseのユーザー更新処理**でだけ起きます。

---

## 理由

Railsは「どのコントローラが、どのモデルを更新するか」で更新対象が決まります。  
Profile編集は `ProfilesController` が `profile` を更新します。  
一方、Deviseは `RegistrationsController` などで `user` を更新します。  
そのため、`ProfilesController` のストロングパラメータに `nickname` を入れていなくても、Devise側で許可していれば `nickname` は更新できます。  
逆に、Profile編集で `nickname` が更新されないのは、そこで `user.nickname` を更新していないからです。

---

## 具体例

「プロフィール編集フォームで nickname を入力して保存したけど変わらない」  
これは、フォーム送信先が `ProfilesController` で、更新しているのが `profile.update(profile_params)` だけだからです。  
`nickname` は `user` の属性なので、この処理では更新されません。  
一方、Deviseのユーザー編集フォーム（例：アカウント編集）から更新すると、Deviseが `user.update(user_params)` を行うため `nickname` が更新されます。

---

## 結論

Profile編集は **Profileの更新**、nickname更新は **Devise（User更新）の担当**です。  
「どの画面が、どのモデルを更新しているか」を分けて考えると迷いません。

# カンマ区切り入力の趣味タグで、大文字・小文字や空白を正規化して重複登録を防ぐ方法


## テーマ

カンマ区切り入力の趣味タグで、大文字・小文字や空白を正規化して重複登録を防ぐ方法

---

## 結論

ユーザー入力はそのまま使わず、**保存前に表記を統一（正規化）してから重複を消す**と、意図しないデータ増加を防げる。

---

## 理由

`uniq` は「完全に同じ文字列」しか重複とみなさない。  
そのため `"Ruby"` と `"ruby"` は別物扱いになり、DBにも別レコードとして残る可能性がある。  
先に小文字化などで表記をそろえると、`uniq` が正しく重複を消せる。

---

## 具体例

入力が `"rails, ruby ,Ruby"` のとき、最初はパーサが `["rails", "ruby", "Ruby"]` を返していた。  
そこでパーサ側で以下を行い、`["rails", "ruby"]` に統一した。

- カンマで分割する
- 前後の空白を消す（`strip`）
- 空文字を捨てる（`blank?`）
- 小文字にそろえる（`downcase`）
- 重複を消す（`uniq`）

この結果、`Profile#update_hobbies_from` のテストが全て通った。

---

## 結論

**「uniqの前にそろえる」**がコツ。  
入力の表記ゆれを正規化してから保存すると、データがきれいに保ててテストも安定する。

- **原因**：`uniq` は `"Ruby"` と `"ruby"` を「別物」と判断する
- **解決**：先に `downcase` で **同じ表記に統一**してから `uniq` するので、重複が消える

覚えやすい合言葉：  
**「uniq は最後。先にそろえる（正規化）！」**

# spec／models／profile_hobby_spec.rb は何のテストか?


## テーマ

spec/models/profile_hobby_spec.rb は何のテストか

---

## 結論

**`spec/models/profile_hobby_spec.rb` は、ProfileHobbyモデルのルール（バリデーション）を確認するテスト。**  
特に「同じ profile と hobby の組み合わせを保存できないか」を確かめている。

---

## 理由

ProfileHobbyは、中間テーブル用のモデル。  
中間テーブルは「関係が正しく保たれるか」が重要になる。  
そのため、重複した関係を作れないというルールを、モデルレベルで保証する必要がある。  
このテストは、そのルールが守られているかを確認している。

---

## 具体例

ProfileHobbyに次のような制約がある場合。

- ある profile が
    
- 同じ hobby を
    
- 2回登録できてはいけない
    

テストでは、

```ruby
profile = create(:profile)
hobby   = create(:hobby)

ProfileHobby.create!(profile:, hobby:)
dup = ProfileHobby.new(profile:, hobby:)

expect(dup).to be_invalid
```

という流れで、  
「1回目は保存できる」  
「2回目はバリデーションで弾かれる」  
ことを確認している。

---

## 結論

**このspecは、ProfileHobbyが「壊れた関係データ」を作らないための安全装置をテストしている。**  
中間テーブルでは特に重要な、実務寄りのモデルテストである。

