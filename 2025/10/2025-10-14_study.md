#daily

## 今日取り組んだタスク

- [ ] 中間試験：ER図
- [ ] paiza Cランク
- [ ] dbdiagram.ioの使い方

---
---
## 一言

全然書き慣れていなかったので、ものすごーく時間がかかりましたがある程度ER図は作れましたw
今週中には、Railsまで進めたいところです.....

最近、ローカル環境ではありますが、アウトプット用のアプリ開発もしております☺️
やっぱりアプリ開発楽しいですね！
早く中間を終わらせて、時間を割いて開発したいっすけど.....多分すぐに応用に取り掛からないと
間に合わないだろうな......



---
---
## 学習内容

### paiza

### Nを取り除いた値を受け取りたい

```ruby
N a_1 ... a_N
```

```ruby
a = gets.split(' ').map(&:to_i)
n = a.shift
a.each { |val| puts val }

```

補足
`n = a.shift`について
ここのメソッドは、deleteではなく、shiftにしないといけない！
なぜなら

|メソッド|削除の基準|戻り値|複数同じ値がある場合|
|---|---|---|---|
|`shift`|先頭の要素（位置）|削除された要素|1つだけ削除|
|`delete`|指定した**値**|削除された値|**同じ値を全部削除**|
したがって、今回消したいのは先頭に位置する要素なので
deleteは不適切


### 配列に値を入れたいなら

```ruby
n = gets.to_i

a = Array.new(n)
n.times { |i| a[i] = gets.to_i }

a.each { |val| puts val }
```


### dbdiagram.io

例：
```sql

Table users {
  id integer [pk]
  first_name varchar
  last_name varchar
  email varchar [not null]
  password varchar [note: 'Hashed password']
  created_at datetime [not null, default: `now()`]
  updated_at datetime
 
  Indexes {
    email [unique, name: "ui_users_email"]
  }
  Note: 'table: users'
}

```

#### テーブルを作成したいなら

１：`Table {テーブル名}`でテーブルを定義する

２：カラムは次のように定義する
　　`{カラム名}{データ型}{設定}`

３：設定の部分は次のように属性を記述する

```
[属性]

- `pk` または `primary key` : プライマリキー
- `unique` : ユニークキー
- `null` または `not null` : Null 許容かNull 非許容
- `default` : デフォルト値
- `increment` : オートインクリメント
- `note` : メタデータとしてのメモ
```


４：インデックスを定義するなら、次のように定義する

```sql
Indexes {
    email [unique, name: "ui_users_email"]
}
Note: 'table: users'

```

補足
1.`Indexes { ... }`

インデックス（索引）を定義するブロックです。  
この中で、**どのカラムにインデックスを貼るか**、**どんな性質を持たせるか**を指定します。


2.`email`

インデックスを貼る対象のカラム名です。  
ここでは「`users` テーブルの `email` カラム」を指しています。

つまり：
> email列に対して検索を高速化し、重複を防ぎたい。


3.`[unique, name: "ui_users_email"]` の部分

これはインデックスの**オプション設定**です。  
DBMLでは、`[ ]` の中に複数の属性をカンマ区切りで指定できます。

|オプション|意味|SQLでの対応|
|---|---|---|
|`unique`|重複を許さない（ユニークインデックス）|`UNIQUE INDEX`|
|`name: "ui_users_email"`|インデックス名を指定|`CREATE UNIQUE INDEX ui_users_email ON users(email);`|

👉 結果として、このDBMLは次のSQLに変換されます：
`CREATE UNIQUE INDEX ui_users_email ON users(email);`


4.`Note: 'table: users'`

これは「このインデックスが `users` テーブルに属する」というメタ情報です。  
（dbdiagram.ioでは、**インデックスをテーブルブロックの外に書く場合**に、この指定が必要になります。）

つまりこの書き方は：

> 「usersテーブルのemailカラムにユニークインデックスを貼る」  
> （インデックス名は ui_users_email）

という意味です。


#### インデックスがある場合とない場合の検索の違い

##### 🔍 1. インデックスなしの検索（遅い場合）

例として、`users` テーブルが 100万件あるとします。
`SELECT * FROM users WHERE email = 'example@gmail.com';`

もし `email` カラムに **インデックスがない**場合、

- データベースは **全行を最初から最後まで1件ずつチェック** します（＝フルスキャン）。
- 処理の流れはこうです：
    
`1. 1行目のemailを見る 2. 一致しなければ次へ 3. 100万件すべて確認`

⏱ 結果：100万件なら「0.5〜2秒以上」かかることもあります。


##### ⚡ 2. インデックスありの検索（速い場合）

同じテーブルでも `email` にインデックスを貼ると：
`CREATE INDEX idx_users_email ON users(email);`

このとき、DBは「索引（インデックス）」を使って検索します。

- インデックスは **電話帳や辞書のように並び替えられたデータ構造（B木）** です。
- 探すときに「真ん中→左右」のように**二分探索**でたどるので、非常に速い。
    

⏱ 結果：同じ検索が「0.001秒以下」で終わることもあります。

### テーブル同士を関連付けをするなら

```sql
Table profiles as prof {
  id integer [pk]
  user_id integer
  bio varchar
  website varchar
  email varchar
  created_at datetime [not null, default: `now()`]
  updated_at datetime
  Indexes {
    user_id [unique, name: "idx_profiles_user_id"]
  }
}


Enum articles_status_enum {
  draft
  published
  private
  deleted
}


Table articles {
  id integer [pk]
  title varchar
  content text [note: 'Content of the article']
  user_id integer
  status articles_status_enum
  created_at datetime [not null, default: `now()`]
  updated_at datetime
  Indexes {
    user_id [name: "idx_articles_user_id"]
  }
  Note: 'table: articles'
}


Ref "fk_articles_user_id_users_id" : articles.user_id > users.id
```

解説
ここで articles テーブルの status カラムは`Enum` というユーザ指定の値を設定できるようにしています。
末尾の`Ref` の箇所で多対1のリレーションシップをarticles と usersで作成しています。

- `<`: 1対多 ( 例:`users. < articles.user_id` )
- `>`: 多対1 ( 例:`articles.user_id > users.id` )
- `-`: 1対1 ( 例:`users.id - profiles.user_id` )
- `<>`: 多対多 ( 例:`shops.id <> products.id` )

---
---
## エラーと対応

- エラー内容：
    
- 対処方法：


---
---
## 学んだこと

- dbdiagram.ioの基本的な使い方
- shiftとdeleteメソッドの違い
- `n.times {|i| a[i] = gets.chomp}` で配列は値を受け取る


---
---
## 教材

- paiza Cランク標準入力
- dbdiagram： https://dbdiagram.io/home


---
---
##### ⏳ 学習時間: 6.7時間  
##### 🌱 コミット数:１コミット 