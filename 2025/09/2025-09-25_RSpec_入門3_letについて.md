### letとlet!の基本的な違い

#### let（遅延評価）
一言で言うと：
必要になった時に初めて作られる変数
```ruby
let(:user) {User.create(name: 'runteq', email: 'runteq@example.com')}

it 'userインスタンスが有効であること' do
	# ⬇️この時点で初めてuserが作成される
	expect(user).to be_valid
end


# FactoryBotを使うケース
# spec/factories/users.rb
FactoryBot.define do
  factory :user do
    name { "らんてくん" }
    sequence(:email) { |n| "runteq_#{n}@example.com" }
    age { 3 }
  end
end

# spec/models/user_spec.rb
RSpec.describe User, type: :model do
  let(:user) { create(:user) }  # 必要になった時に作成される
  
  it 'userが有効であること' do
    # ↓この時点で初めてFactoryBotでuserが作成される
    expect(user).to be_valid
  end
  
  it 'userを使わないテスト' do
    # letのuserを使わず、新しいオブジェクトを作成
    invalid_user = build(:user, name: nil)
    
    # letのuserは参照しないので、作成されない
    expect(invalid_user).to be_invalid
  end
end
```


### let!（即時評価）
一言で言うと：
定義された時点ですぐに作成される変数
```ruby
let!(:user) { User.create(name: 'runteq', email: 'runteq@example.com') }

it 'userインスタンスが有効であること' do
	# ↓この時点では既にuserが作成済み
	expect(user).to be_valid
end


# FactoryBotを使うケース
# spec/factories/users.rb
FactoryBot.define do
  factory :user do
    name { "らんてくん" }
    sequence(:email) { |n| "runteq_#{n}@example.com" }
    age { 3 }
  end
end

# spec/models/user_spec.rb
RSpec.describe User, type: :model do
	# let!は即座に評価される（FactoryBot使用）
	let!(:user) { create(:user) }
  
	it 'userインスタンスが有効であること' do
    # ↓この時点では既にuserが作成済み
	    expect(user).to be_valid
	end
  
	it 'userを使わないテスト' do
	    # userを参照しないが、let!なので既に作成されている（非効率）
	    invalid_user = build(:user, name: nil)
	    expect(invalid_user).to be_invalid
	end
end
```

解説
**何が起きているか：**

- テスト1実行前：`let!`でuserがDBに作成される
- テスト1実行：作成済みのuserを使用（効率的）
- テスト2実行前：`let!`で**また新しいuser**がDBに作成される
- テスト2実行：作成されたuserを全く使わない（**無駄**）